\chapter{ CFD-DEM IMPLEMENTATION IN OPENFOAM} 
\label{chapter4} 

The CFD-DEM solver leverages the OpenFOAM framework to simulate fluid-particle interactions. The core of the implementation focuses on mesh generation, the definition of sediment flow domains, modeling spaces, sediment geometries, and ensuring accurate geometry intersection for computational purposes.\par

\section{Geometry and Meshing}

Mesh generation forms the foundation of the CFD-DEM simulation, as it defines the computational domain and partitions the space into discrete elements for numerical analysis. The backgroundMesh class is responsible for this process, providing flexibility to model sediment-laden flows in complex geometries.\par

\subsection{Sediment involved Flow Domain}

The computational domain represents a flow field interacting with sediment particles, which is a fundamental part of the CFD-DEM coupling. The domain is discretized using the backgroundMesh class, ensuring an adaptable grid resolution. This approach facilitates handling the complex interactions between fluid and sediment aggregates while maintaining computational efficiency.\par

The flow domain is bound by a three-dimensional Cartesian grid defined by:\par

\begin{enumerate}
	\item  \textbf{Bounds}: Specified by meshMin\_ and meshMax\_, which determine the global minimum and maximum coordinates.\par
	\item  \textbf{Resolution}: A scalar value, resolution\_, sets the grid's fineness. This influences the discretization level, balancing accuracy, and computational cost.\par
\end{enumerate}

The \textbf{backgroundMesh} class systematically subdivides the domain into blocks, with each block containing a specific number of cells based on the resolution. The cells in this grid adapt to include sediment geometries through an intersection algorithm. Using functions like intersectCube and intersectCubes, sediment boundaries are identified and incorporated into the mesh.\par

\subsection{Modelling of Space}

The spatial model is constructed using the backgroundMesh object, which generates a hierarchical data structure (backgroundBlocks\_) to store individual blocks of the domain. Key steps in this process include:\par

\begin{enumerate}
	\item  \textbf{Vertex Creation}: Eight vertices for each block are created using the createVertices function.\par
	\item  \textbf{Dynamic Allocation}: The createListPointers function dynamically allocates memory for the hierarchical block structure.\par
	\item  \textbf{Point Location}: The algorithm identifies which block a given point belongs to using getBlockIndexContainingPoint.\par
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{Figures/Chapters/C04/background_mesh.png}
	\caption{A typical backgroundMesh having $10\times 10\times 10$ regular hexahedral backgroundBlocks representing computational mesh}
	\label{fig:A typical backgroundMesh}
\end{figure}

\subsection{Modelling of Sediments}

Sediments are modelled as discrete aggregates represented by the cubeAggregate and cubeAggregates classes. Each sediment aggregate is defined by:\par

\begin{enumerate}
	\item  \textbf{Geometry}: Local and global point fields (localPoints\_ and globalPoints\_) describe the sediment's shape.\par
	\item  \textbf{Boundary Representation}: The pointList points\_ and the faceList faces\_ and  provides a detailed geometry using quadrilateral face elements derived from functions like createQuadFaces.\par
\end{enumerate}

The sediments are introduced into the flow domain using a particle size distribution (PSD) to control size variation. The cubeAggregates class generates sediment particles with attributes like size and orientation, leveraging functions such as:\par

\begin{enumerate}
	\item  generateAggregates: Generates sediment aggregates of varying sizes and orientations.\par
	\item  translate and rotate: Apply spatial transformations to position and orient sediments within the flow domain.\par
	\item  locate: Determines the precise placement of the sediment within the computational grid.\par
\end{enumerate}

These aggregates are then intersected with the background mesh using the intersectCube method, which identifies and incorporates sediment geometry into the fluid mesh.\par

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{Figures/Chapters/C04/single_cube_sediment.png}
	\caption{Modelling of sediment using a cube geometry}
	\label{fig:Modelling of sediment using a cube geometry}
\end{figure}

\subsection{Geometry Intersection}

Geometry intersection ensures integration of sediment geometry into the computational domain as solid boundaries. The focus is on detecting and resolving interactions between complex surfaces, such as aggregates and the background block, to ensure accurate physical representation in sediment flow modeling. Key components include methods for surface intersection detection, cut face generation, and data merging for intersected geometries.\par

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{Figures/Chapters/C04/immersed_boundary.png}
	\caption{Development of immersed boundary of a particle}
	\label{fig:Development of immersed boundary of particle}
\end{figure}

\begin{enumerate}
	\item  \textbf{Bounding Box Matching}: Each sediment's bounding box (getBoundBox) is mapped to the corresponding blocks in the computational domain.\par
	\item  \textbf{Closed Surface Intersections}: The sediment's boundary faces are checked for intersections with the domain grid.\par
	\item  \textbf{Dynamic Updates}: The mesh dynamically adapts by updating vertices, faces, and cells based on sediment geometry.\par
\end{enumerate}

\subsubsection{Intersection with Closed Surfaces}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{Figures/Chapters/C04/cube_intersection.png}
	\caption{Intersection of a cube geometry with background mesh}
	\label{fig:Intersection of a cube geometry with background mesh}
\end{figure}

The intersectClosedSurface function handles the process of intersecting a cube aggregate's triangulated surface (faces and points) with a backgroundBlock. It identifies intersection points and reconstructs the geometry of the intersected surfaces.\par

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{Figures/Chapters/C04/multiple_intersections.png}
	\caption{Introduction of multiple immersed boundaries in computational domain representing multiple particles}
	\label{fig:Introduction of multiple immersed boundaries in computational domain representing multiple particles}
\end{figure}

\section{Fluid Phase Modelling}

The fluid phase in the solver is modelled using locally averaged incompressible Navier-Stokes equations. The governing equations for the fluid flow are the mass conservation (continuity) and momentum conservation equations:

\subsection{Governing Equations}

\textbf{Continuity Equation:}
\begin{equation}
	\nabla \cdot \mathbf{U} = 0
	\label{eqn:continuity}
\end{equation}

\textbf{Momentum Equation:}
\begin{equation}
	\frac{\partial \mathbf{U}}{\partial t} + \nabla \cdot (\mathbf{U} \mathbf{U}) - \nabla \cdot (\nu_{eff} \nabla \mathbf{U}) = -\frac{1}{\rho} \nabla p + \mathbf{g} + \mathbf{f}_{ib}
	\label{eqn:momentum}
\end{equation}
where $\mathbf{U}$ is the fluid velocity field, $p$ is the pressure, $\rho$ is the fluid density, $\nu_{eff}$ is the effective kinematic viscosity (molecular + turbulent), $\mathbf{g}$ is the gravitational acceleration, and $\mathbf{f}_{ib}$ represents the immersed boundary forcing term accounting for the presence of solid particles.

\subsection{Turbulence Modelling}
The solver incorporates turbulence modelling through the Reynolds-Averaged Navier-Stokes (RANS) approach. In this framework, the instantaneous velocity field is decomposed into a mean component ($\bar{\mathbf{U}}$) and a fluctuating component ($\mathbf{u}'$):
\begin{equation}
	\mathbf{U} = \bar{\mathbf{U}} + \mathbf{u}'
\end{equation}

Substituting this into the Navier-Stokes equations and averaging yields the RANS equations, which introduce an additional term known as the Reynolds stress tensor ($\tau_{ij} = -\rho \overline{u'_i u'_j}$). To close the system of equations, the Boussinesq hypothesis is employed, relating the Reynolds stresses to the mean velocity gradients via an eddy viscosity ($\nu_t$):
\begin{equation}
	-\overline{u'_i u'_j} = \nu_t \left( \frac{\partial \bar{U}_i}{\partial x_j} + \frac{\partial \bar{U}_j}{\partial x_i} \right) - \frac{2}{3} k \delta_{ij}
\end{equation}
where $k$ is the turbulent kinetic energy. The effective viscosity in the momentum equation becomes $\nu_{eff} = \nu + \nu_t$. The specific turbulence model (e.g., $k-\epsilon$, $k-\omega$ SST) is selected at runtime using OpenFOAM's standard turbulence modelling framework (`turbulentTransportModel`), allowing for flexibility in choosing the appropriate closure for different flow regimes.

\subsection{Volume of Fluid (VOF) Method}
To capture the free surface interface between two immiscible fluids (e.g., air and water), the Volume of Fluid (VOF) method is employed. The phase fraction $\alpha$ is governed by the transport equation:

\begin{equation}
	\frac{\partial \alpha}{\partial t} + \nabla \cdot (\mathbf{U} \alpha) + \nabla \cdot (\mathbf{U}_r \alpha (1-\alpha)) = 0
	\label{eqn:alpha_eqn}
\end{equation}
where $\mathbf{U}_r$ is the relative compression velocity used to sharpen the interface. The physical properties of the fluid mixture are calculated as weighted averages:
\begin{equation}
	\rho = \alpha \rho_1 + (1-\alpha) \rho_2
\end{equation}
\begin{equation}
	\mu = \alpha \mu_1 + (1-\alpha) \mu_2
\end{equation}

\subsection{PIMPLE Algorithm}
The pressure-velocity coupling is handled using the PIMPLE algorithm, which combines the PISO and SIMPLE algorithms. This ensures numerical stability and convergence for transient flows with large time steps. The algorithm solves the momentum predictor and pressure corrector steps iteratively within each time step.

\section{Discrete Element Method (DEM) Implementation}

The Discrete Element Method (DEM) is implemented as a standalone library within the `bashyal/Src/dem` directory, designed to handle the Lagrangian dynamics of solid particles. The implementation is modular, consisting of several key components: Particle Class, Space Registry, Time Registry, and Contact Models.

\subsection{Particle Class}
The `particle` class forms the core of the DEM implementation. It extends the basic geometric boundary class with physical properties and kinematic state variables.

\textbf{Physical Properties:}
Each particle stores its mass ($m$), moment of inertia tensor ($\mathbf{I}$), and characteristic diameter ($d_c$).

\textbf{Kinematic State:}
The state of a particle is defined by its position ($\mathbf{x}$), orientation (quaternion $\mathbf{q}$), linear velocity ($\mathbf{v}$), and angular velocity ($\boldsymbol{\omega}$).

\textbf{Equations of Motion:}
The motion of each particle $i$ is governed by Newton's second law for translation and rotation:
\begin{equation}
	m_i \frac{d\mathbf{v}_i}{dt} = \mathbf{F}_{total} = \mathbf{F}_{contact} + \mathbf{F}_{fluid} + \mathbf{F}_{gravity}
\end{equation}
\begin{equation}
	\mathbf{I}_i \frac{d\boldsymbol{\omega}_i}{dt} + \boldsymbol{\omega}_i \times (\mathbf{I}_i \boldsymbol{\omega}_i) = \mathbf{T}_{total} = \mathbf{T}_{contact} + \mathbf{T}_{fluid}
\end{equation}

\textbf{Time Integration:}
A semi-implicit Euler integration scheme is used to update the particle state:
\begin{equation}
	\mathbf{v}_{t+\Delta t} = \mathbf{v}_t + \frac{\mathbf{F}_{total}}{m} \Delta t
\end{equation}
\begin{equation}
	\mathbf{x}_{t+\Delta t} = \mathbf{x}_t + \mathbf{v}_{t+\Delta t} \Delta t
\end{equation}
Angular quantities are updated similarly, with quaternion normalization to maintain valid orientation.

\subsection{Space Registry}
To efficiently handle particle interactions and avoid $O(N^2)$ complexity in collision detection, a `spaceRegistry` class is implemented.

\textbf{Spatial Partitioning:}
The simulation domain is divided into a grid of cells. Each particle is registered to the cells it overlaps with based on its bounding box. This allows the solver to check for collisions only between particles in the same or neighboring cells.

\textbf{Bounding Box Check:}
Before performing detailed collision detection, a fast axis-aligned bounding box (AABB) overlap check is performed to quickly cull non-colliding pairs.

\subsection{Time Registry and I/O}
The `timeRegistry` class manages the simulation time, time-stepping, and data input/output.

\textbf{Time Stepping:}
It controls the advancement of the DEM simulation time, which may be sub-cycled relative to the CFD time step to ensure stability of the contact mechanics.

\textbf{Data Output (PVD/VTP):}
The registry handles the writing of particle data to VTK PolyData (.vtp) files. A ParaView Data (.pvd) file is maintained to link these time-series files, allowing for easy visualization and animation of particle motion in ParaView.

\subsection{Collision Detection: GJK Algorithm}
Robust collision detection for arbitrary convex shapes (like the cubes used in this study) is achieved using the Gilbert-Johnson-Keerthi (GJK) algorithm.

\textbf{Principle:}
The GJK algorithm determines if two convex shapes overlap by checking if the origin is contained within their Minkowski Difference ($A \ominus B = \{a - b | a \in A, b \in B\}$).

\textbf{Implementation Details:}
\begin{itemize}
	\item \textbf{Support Function:} A key component is the support function $S_A(\mathbf{d})$, which returns the point on shape $A$ furthest in direction $\mathbf{d}$. For a cube, this is one of its vertices.
	\item \textbf{Simplex Evolution:} The algorithm iteratively builds a simplex (line, triangle, tetrahedron) inside the Minkowski difference to enclose the origin.
	\item \textbf{EPA (Expanding Polytope Algorithm):} If a collision is detected, the EPA is used to determine the penetration depth and contact normal by expanding the simplex to find the closest point on the boundary of the Minkowski difference to the origin.
\end{itemize}

\subsection{Contact Force Model}
Once a collision is detected, the interaction forces are calculated using the Walton-Braun hysteretic spring model.

\textbf{Normal Force:}
\begin{equation}
	F_n = \begin{cases} 
		k_1 \delta & \text{Loading } (\dot{\delta} \ge 0) \\
		k_2 (\delta - \delta_0) & \text{Unloading } (\dot{\delta} < 0)
	\end{cases}
\end{equation}
where $k_1$ and $k_2$ are loading and unloading stiffnesses, and $\delta_0$ is the residual overlap. This hysteresis accounts for energy dissipation (plasticity).

\textbf{Tangential Force:}
A Coulomb friction model limits the tangential force:
\begin{equation}
	F_t = \min(|k_t \xi|, \mu F_n)
\end{equation}

\section{CFD-DEM Coupling}

The coupling between the fluid solver (`fineDEMfoam`) and the DEM library is achieved through a partitioned approach, where the fluid and solid equations are solved sequentially within each time step.

\subsection{Solver Structure: fineDEMfoam}
The `fineDEMfoam` solver integrates the DEM loop into the standard PIMPLE algorithm. The high-level algorithm is:
\begin{enumerate}
	\item Initialize DEM particles (`particlesGenerator`).
	\item \textbf{Time Loop:}
	\begin{enumerate}
		\item Calculate Immersed Boundary (IBM) fields ($\epsilon, \mathbf{U}_{solid}$).
		\item \textbf{PIMPLE Loop (Fluid Solver):}
		\begin{enumerate}
			\item Solve VOF equation ($\alpha$).
			\item Solve Momentum predictor ($\mathbf{U}$).
			\item Solve Pressure corrector ($p$).
			\item \textbf{Coupling Step:} Calculate fluid forces on particles.
		\end{enumerate}
		\item \textbf{DEM Loop:}
		\begin{enumerate}
			\item Detect collisions (Space Registry + GJK).
			\item Calculate contact forces.
			\item Apply fluid and contact forces.
			\item Update particle positions and velocities.
		\end{enumerate}
		\item Write output (Fluid fields + Particle VTPs).
	\end{enumerate}
\end{enumerate}

\subsection{Immersed Boundary Method (IBM)}
The presence of particles in the fluid is represented using a Fictitious Domain method.

\textbf{Solid Volume Fraction ($\epsilon$):}
A field $\epsilon$ is calculated to identify cells occupied by particles. In the current implementation, a cell is considered occupied ($\epsilon=1$) if its center lies within the particle's radius (approximated as a sphere for the IBM mapping):
\begin{equation}
	\epsilon_{cell} = \begin{cases} 1 & \text{if } |\mathbf{x}_{cell} - \mathbf{x}_{particle}| < R \\ 0 & \text{otherwise} \end{cases}
\end{equation}

\textbf{Solid Velocity Field ($\mathbf{U}_{solid}$):}
For cells inside a particle, a solid velocity is constructed to enforce the no-slip condition:
\begin{equation}
	\mathbf{U}_{solid} = \mathbf{v}_p + \boldsymbol{\omega}_p \times (\mathbf{x}_{cell} - \mathbf{x}_{particle})
\end{equation}

\subsection{Force Calculation and Application}
The two-way coupling requires the exchange of forces.

\textbf{Fluid-to-Particle Force:}
The force exerted by the fluid on the particle is computed by integrating the pressure gradient and viscous stresses over the particle volume. In the implemented code, this is approximated by summing the contributions from occupied cells:
\begin{equation}
	\mathbf{F}_{fluid} = \sum_{cells} (-\nabla p)_{cell} V_{cell} \epsilon_{cell} + m_p \mathbf{g}
\end{equation}
This force is then applied to the particle in the DEM update step.

\textbf{Particle-to-Fluid Coupling:}
The influence of particles on the fluid is typically handled via the IBM forcing term in the momentum equation, which forces the fluid velocity $\mathbf{U}$ towards $\mathbf{U}_{solid}$ in occupied regions, effectively acting as a momentum sink/source.
\par
